//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by \generate-code.bat.
//
//     Changes to this file will be lost when the code is regenerated.
//     The build server regenerates the code before each build and a pre-build
//     step will regenerate the code on each local build.
//
//     See https://github.com/angularsen/UnitsNet/wiki/Adding-a-New-Unit for how to add or edit units.
//
//     Add CustomCode\Quantities\MyQuantity.extra.cs files to add code to generated quantities.
//     Add Extensions\MyQuantityExtensions.cs to decorate quantities with new behavior.
//     Add UnitDefinitions\MyQuantity.json and run GeneratUnits.bat to generate new units or quantities.
//
// </auto-generated>
//------------------------------------------------------------------------------

// Copyright (c) 2013 Andreas Gullberg Larsen (andreas.larsen84@gmail.com).
// https://github.com/angularsen/UnitsNet
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

using System;

// Windows Runtime Component does not support extension methods and method overloads: https://msdn.microsoft.com/en-us/library/br230301.aspx
#if !WINDOWS_UWP
namespace UnitsNet.Extensions.NumberToInformation
{
    public static class NumberToInformationExtensions
    {
        /// <inheritdoc cref="Information.FromBits(UnitsNet.QuantityValue)" />
        public static Information Bits<T>(this T value) => Information.FromBits(Convert.ToDouble(value));

        /// <inheritdoc cref="Information.FromBytes(UnitsNet.QuantityValue)" />
        public static Information Bytes<T>(this T value) => Information.FromBytes(Convert.ToDouble(value));

        /// <inheritdoc cref="Information.FromExabits(UnitsNet.QuantityValue)" />
        public static Information Exabits<T>(this T value) => Information.FromExabits(Convert.ToDouble(value));

        /// <inheritdoc cref="Information.FromExabytes(UnitsNet.QuantityValue)" />
        public static Information Exabytes<T>(this T value) => Information.FromExabytes(Convert.ToDouble(value));

        /// <inheritdoc cref="Information.FromExbibits(UnitsNet.QuantityValue)" />
        public static Information Exbibits<T>(this T value) => Information.FromExbibits(Convert.ToDouble(value));

        /// <inheritdoc cref="Information.FromExbibytes(UnitsNet.QuantityValue)" />
        public static Information Exbibytes<T>(this T value) => Information.FromExbibytes(Convert.ToDouble(value));

        /// <inheritdoc cref="Information.FromGibibits(UnitsNet.QuantityValue)" />
        public static Information Gibibits<T>(this T value) => Information.FromGibibits(Convert.ToDouble(value));

        /// <inheritdoc cref="Information.FromGibibytes(UnitsNet.QuantityValue)" />
        public static Information Gibibytes<T>(this T value) => Information.FromGibibytes(Convert.ToDouble(value));

        /// <inheritdoc cref="Information.FromGigabits(UnitsNet.QuantityValue)" />
        public static Information Gigabits<T>(this T value) => Information.FromGigabits(Convert.ToDouble(value));

        /// <inheritdoc cref="Information.FromGigabytes(UnitsNet.QuantityValue)" />
        public static Information Gigabytes<T>(this T value) => Information.FromGigabytes(Convert.ToDouble(value));

        /// <inheritdoc cref="Information.FromKibibits(UnitsNet.QuantityValue)" />
        public static Information Kibibits<T>(this T value) => Information.FromKibibits(Convert.ToDouble(value));

        /// <inheritdoc cref="Information.FromKibibytes(UnitsNet.QuantityValue)" />
        public static Information Kibibytes<T>(this T value) => Information.FromKibibytes(Convert.ToDouble(value));

        /// <inheritdoc cref="Information.FromKilobits(UnitsNet.QuantityValue)" />
        public static Information Kilobits<T>(this T value) => Information.FromKilobits(Convert.ToDouble(value));

        /// <inheritdoc cref="Information.FromKilobytes(UnitsNet.QuantityValue)" />
        public static Information Kilobytes<T>(this T value) => Information.FromKilobytes(Convert.ToDouble(value));

        /// <inheritdoc cref="Information.FromMebibits(UnitsNet.QuantityValue)" />
        public static Information Mebibits<T>(this T value) => Information.FromMebibits(Convert.ToDouble(value));

        /// <inheritdoc cref="Information.FromMebibytes(UnitsNet.QuantityValue)" />
        public static Information Mebibytes<T>(this T value) => Information.FromMebibytes(Convert.ToDouble(value));

        /// <inheritdoc cref="Information.FromMegabits(UnitsNet.QuantityValue)" />
        public static Information Megabits<T>(this T value) => Information.FromMegabits(Convert.ToDouble(value));

        /// <inheritdoc cref="Information.FromMegabytes(UnitsNet.QuantityValue)" />
        public static Information Megabytes<T>(this T value) => Information.FromMegabytes(Convert.ToDouble(value));

        /// <inheritdoc cref="Information.FromPebibits(UnitsNet.QuantityValue)" />
        public static Information Pebibits<T>(this T value) => Information.FromPebibits(Convert.ToDouble(value));

        /// <inheritdoc cref="Information.FromPebibytes(UnitsNet.QuantityValue)" />
        public static Information Pebibytes<T>(this T value) => Information.FromPebibytes(Convert.ToDouble(value));

        /// <inheritdoc cref="Information.FromPetabits(UnitsNet.QuantityValue)" />
        public static Information Petabits<T>(this T value) => Information.FromPetabits(Convert.ToDouble(value));

        /// <inheritdoc cref="Information.FromPetabytes(UnitsNet.QuantityValue)" />
        public static Information Petabytes<T>(this T value) => Information.FromPetabytes(Convert.ToDouble(value));

        /// <inheritdoc cref="Information.FromTebibits(UnitsNet.QuantityValue)" />
        public static Information Tebibits<T>(this T value) => Information.FromTebibits(Convert.ToDouble(value));

        /// <inheritdoc cref="Information.FromTebibytes(UnitsNet.QuantityValue)" />
        public static Information Tebibytes<T>(this T value) => Information.FromTebibytes(Convert.ToDouble(value));

        /// <inheritdoc cref="Information.FromTerabits(UnitsNet.QuantityValue)" />
        public static Information Terabits<T>(this T value) => Information.FromTerabits(Convert.ToDouble(value));

        /// <inheritdoc cref="Information.FromTerabytes(UnitsNet.QuantityValue)" />
        public static Information Terabytes<T>(this T value) => Information.FromTerabytes(Convert.ToDouble(value));

    }
}
#endif
