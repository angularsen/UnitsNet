//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by \generate-code.bat.
//
//     Changes to this file will be lost when the code is regenerated.
//     The build server regenerates the code before each build and a pre-build
//     step will regenerate the code on each local build.
//
//     See https://github.com/angularsen/UnitsNet/wiki/Adding-a-New-Unit for how to add or edit units.
//
//     Add CustomCode\Quantities\MyQuantity.extra.cs files to add code to generated quantities.
//     Add Extensions\MyQuantityExtensions.cs to decorate quantities with new behavior.
//     Add UnitDefinitions\MyQuantity.json and run GeneratUnits.bat to generate new units or quantities.
//
// </auto-generated>
//------------------------------------------------------------------------------

// Copyright (c) 2013 Andreas Gullberg Larsen (andreas.larsen84@gmail.com).
// https://github.com/angularsen/UnitsNet
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

using System;

// Windows Runtime Component does not support extension methods and method overloads: https://msdn.microsoft.com/en-us/library/br230301.aspx
#if !WINDOWS_UWP
namespace UnitsNet.Extensions.NumberToInformation
{
    public static class NumberToInformationExtensions
    {
        #region Bit

        /// <inheritdoc cref="Information.FromBits(UnitsNet.QuantityValue)" />
        public static Information Bits<T>(this T value) => Information.FromBits(Convert.ToDouble(value));

        /// <inheritdoc cref="Information.FromBits(UnitsNet.QuantityValue)" />
        public static Information? Bits<T>(this T? value) where T : struct => Information.FromBits(value == null ? (double?)null : Convert.ToDouble(value.Value));

        #endregion

        #region Byte

        /// <inheritdoc cref="Information.FromBytes(UnitsNet.QuantityValue)" />
        public static Information Bytes<T>(this T value) => Information.FromBytes(Convert.ToDouble(value));

        /// <inheritdoc cref="Information.FromBytes(UnitsNet.QuantityValue)" />
        public static Information? Bytes<T>(this T? value) where T : struct => Information.FromBytes(value == null ? (double?)null : Convert.ToDouble(value.Value));

        #endregion

        #region Exabit

        /// <inheritdoc cref="Information.FromExabits(UnitsNet.QuantityValue)" />
        public static Information Exabits<T>(this T value) => Information.FromExabits(Convert.ToDouble(value));

        /// <inheritdoc cref="Information.FromExabits(UnitsNet.QuantityValue)" />
        public static Information? Exabits<T>(this T? value) where T : struct => Information.FromExabits(value == null ? (double?)null : Convert.ToDouble(value.Value));

        #endregion

        #region Exabyte

        /// <inheritdoc cref="Information.FromExabytes(UnitsNet.QuantityValue)" />
        public static Information Exabytes<T>(this T value) => Information.FromExabytes(Convert.ToDouble(value));

        /// <inheritdoc cref="Information.FromExabytes(UnitsNet.QuantityValue)" />
        public static Information? Exabytes<T>(this T? value) where T : struct => Information.FromExabytes(value == null ? (double?)null : Convert.ToDouble(value.Value));

        #endregion

        #region Exbibit

        /// <inheritdoc cref="Information.FromExbibits(UnitsNet.QuantityValue)" />
        public static Information Exbibits<T>(this T value) => Information.FromExbibits(Convert.ToDouble(value));

        /// <inheritdoc cref="Information.FromExbibits(UnitsNet.QuantityValue)" />
        public static Information? Exbibits<T>(this T? value) where T : struct => Information.FromExbibits(value == null ? (double?)null : Convert.ToDouble(value.Value));

        #endregion

        #region Exbibyte

        /// <inheritdoc cref="Information.FromExbibytes(UnitsNet.QuantityValue)" />
        public static Information Exbibytes<T>(this T value) => Information.FromExbibytes(Convert.ToDouble(value));

        /// <inheritdoc cref="Information.FromExbibytes(UnitsNet.QuantityValue)" />
        public static Information? Exbibytes<T>(this T? value) where T : struct => Information.FromExbibytes(value == null ? (double?)null : Convert.ToDouble(value.Value));

        #endregion

        #region Gibibit

        /// <inheritdoc cref="Information.FromGibibits(UnitsNet.QuantityValue)" />
        public static Information Gibibits<T>(this T value) => Information.FromGibibits(Convert.ToDouble(value));

        /// <inheritdoc cref="Information.FromGibibits(UnitsNet.QuantityValue)" />
        public static Information? Gibibits<T>(this T? value) where T : struct => Information.FromGibibits(value == null ? (double?)null : Convert.ToDouble(value.Value));

        #endregion

        #region Gibibyte

        /// <inheritdoc cref="Information.FromGibibytes(UnitsNet.QuantityValue)" />
        public static Information Gibibytes<T>(this T value) => Information.FromGibibytes(Convert.ToDouble(value));

        /// <inheritdoc cref="Information.FromGibibytes(UnitsNet.QuantityValue)" />
        public static Information? Gibibytes<T>(this T? value) where T : struct => Information.FromGibibytes(value == null ? (double?)null : Convert.ToDouble(value.Value));

        #endregion

        #region Gigabit

        /// <inheritdoc cref="Information.FromGigabits(UnitsNet.QuantityValue)" />
        public static Information Gigabits<T>(this T value) => Information.FromGigabits(Convert.ToDouble(value));

        /// <inheritdoc cref="Information.FromGigabits(UnitsNet.QuantityValue)" />
        public static Information? Gigabits<T>(this T? value) where T : struct => Information.FromGigabits(value == null ? (double?)null : Convert.ToDouble(value.Value));

        #endregion

        #region Gigabyte

        /// <inheritdoc cref="Information.FromGigabytes(UnitsNet.QuantityValue)" />
        public static Information Gigabytes<T>(this T value) => Information.FromGigabytes(Convert.ToDouble(value));

        /// <inheritdoc cref="Information.FromGigabytes(UnitsNet.QuantityValue)" />
        public static Information? Gigabytes<T>(this T? value) where T : struct => Information.FromGigabytes(value == null ? (double?)null : Convert.ToDouble(value.Value));

        #endregion

        #region Kibibit

        /// <inheritdoc cref="Information.FromKibibits(UnitsNet.QuantityValue)" />
        public static Information Kibibits<T>(this T value) => Information.FromKibibits(Convert.ToDouble(value));

        /// <inheritdoc cref="Information.FromKibibits(UnitsNet.QuantityValue)" />
        public static Information? Kibibits<T>(this T? value) where T : struct => Information.FromKibibits(value == null ? (double?)null : Convert.ToDouble(value.Value));

        #endregion

        #region Kibibyte

        /// <inheritdoc cref="Information.FromKibibytes(UnitsNet.QuantityValue)" />
        public static Information Kibibytes<T>(this T value) => Information.FromKibibytes(Convert.ToDouble(value));

        /// <inheritdoc cref="Information.FromKibibytes(UnitsNet.QuantityValue)" />
        public static Information? Kibibytes<T>(this T? value) where T : struct => Information.FromKibibytes(value == null ? (double?)null : Convert.ToDouble(value.Value));

        #endregion

        #region Kilobit

        /// <inheritdoc cref="Information.FromKilobits(UnitsNet.QuantityValue)" />
        public static Information Kilobits<T>(this T value) => Information.FromKilobits(Convert.ToDouble(value));

        /// <inheritdoc cref="Information.FromKilobits(UnitsNet.QuantityValue)" />
        public static Information? Kilobits<T>(this T? value) where T : struct => Information.FromKilobits(value == null ? (double?)null : Convert.ToDouble(value.Value));

        #endregion

        #region Kilobyte

        /// <inheritdoc cref="Information.FromKilobytes(UnitsNet.QuantityValue)" />
        public static Information Kilobytes<T>(this T value) => Information.FromKilobytes(Convert.ToDouble(value));

        /// <inheritdoc cref="Information.FromKilobytes(UnitsNet.QuantityValue)" />
        public static Information? Kilobytes<T>(this T? value) where T : struct => Information.FromKilobytes(value == null ? (double?)null : Convert.ToDouble(value.Value));

        #endregion

        #region Mebibit

        /// <inheritdoc cref="Information.FromMebibits(UnitsNet.QuantityValue)" />
        public static Information Mebibits<T>(this T value) => Information.FromMebibits(Convert.ToDouble(value));

        /// <inheritdoc cref="Information.FromMebibits(UnitsNet.QuantityValue)" />
        public static Information? Mebibits<T>(this T? value) where T : struct => Information.FromMebibits(value == null ? (double?)null : Convert.ToDouble(value.Value));

        #endregion

        #region Mebibyte

        /// <inheritdoc cref="Information.FromMebibytes(UnitsNet.QuantityValue)" />
        public static Information Mebibytes<T>(this T value) => Information.FromMebibytes(Convert.ToDouble(value));

        /// <inheritdoc cref="Information.FromMebibytes(UnitsNet.QuantityValue)" />
        public static Information? Mebibytes<T>(this T? value) where T : struct => Information.FromMebibytes(value == null ? (double?)null : Convert.ToDouble(value.Value));

        #endregion

        #region Megabit

        /// <inheritdoc cref="Information.FromMegabits(UnitsNet.QuantityValue)" />
        public static Information Megabits<T>(this T value) => Information.FromMegabits(Convert.ToDouble(value));

        /// <inheritdoc cref="Information.FromMegabits(UnitsNet.QuantityValue)" />
        public static Information? Megabits<T>(this T? value) where T : struct => Information.FromMegabits(value == null ? (double?)null : Convert.ToDouble(value.Value));

        #endregion

        #region Megabyte

        /// <inheritdoc cref="Information.FromMegabytes(UnitsNet.QuantityValue)" />
        public static Information Megabytes<T>(this T value) => Information.FromMegabytes(Convert.ToDouble(value));

        /// <inheritdoc cref="Information.FromMegabytes(UnitsNet.QuantityValue)" />
        public static Information? Megabytes<T>(this T? value) where T : struct => Information.FromMegabytes(value == null ? (double?)null : Convert.ToDouble(value.Value));

        #endregion

        #region Pebibit

        /// <inheritdoc cref="Information.FromPebibits(UnitsNet.QuantityValue)" />
        public static Information Pebibits<T>(this T value) => Information.FromPebibits(Convert.ToDouble(value));

        /// <inheritdoc cref="Information.FromPebibits(UnitsNet.QuantityValue)" />
        public static Information? Pebibits<T>(this T? value) where T : struct => Information.FromPebibits(value == null ? (double?)null : Convert.ToDouble(value.Value));

        #endregion

        #region Pebibyte

        /// <inheritdoc cref="Information.FromPebibytes(UnitsNet.QuantityValue)" />
        public static Information Pebibytes<T>(this T value) => Information.FromPebibytes(Convert.ToDouble(value));

        /// <inheritdoc cref="Information.FromPebibytes(UnitsNet.QuantityValue)" />
        public static Information? Pebibytes<T>(this T? value) where T : struct => Information.FromPebibytes(value == null ? (double?)null : Convert.ToDouble(value.Value));

        #endregion

        #region Petabit

        /// <inheritdoc cref="Information.FromPetabits(UnitsNet.QuantityValue)" />
        public static Information Petabits<T>(this T value) => Information.FromPetabits(Convert.ToDouble(value));

        /// <inheritdoc cref="Information.FromPetabits(UnitsNet.QuantityValue)" />
        public static Information? Petabits<T>(this T? value) where T : struct => Information.FromPetabits(value == null ? (double?)null : Convert.ToDouble(value.Value));

        #endregion

        #region Petabyte

        /// <inheritdoc cref="Information.FromPetabytes(UnitsNet.QuantityValue)" />
        public static Information Petabytes<T>(this T value) => Information.FromPetabytes(Convert.ToDouble(value));

        /// <inheritdoc cref="Information.FromPetabytes(UnitsNet.QuantityValue)" />
        public static Information? Petabytes<T>(this T? value) where T : struct => Information.FromPetabytes(value == null ? (double?)null : Convert.ToDouble(value.Value));

        #endregion

        #region Tebibit

        /// <inheritdoc cref="Information.FromTebibits(UnitsNet.QuantityValue)" />
        public static Information Tebibits<T>(this T value) => Information.FromTebibits(Convert.ToDouble(value));

        /// <inheritdoc cref="Information.FromTebibits(UnitsNet.QuantityValue)" />
        public static Information? Tebibits<T>(this T? value) where T : struct => Information.FromTebibits(value == null ? (double?)null : Convert.ToDouble(value.Value));

        #endregion

        #region Tebibyte

        /// <inheritdoc cref="Information.FromTebibytes(UnitsNet.QuantityValue)" />
        public static Information Tebibytes<T>(this T value) => Information.FromTebibytes(Convert.ToDouble(value));

        /// <inheritdoc cref="Information.FromTebibytes(UnitsNet.QuantityValue)" />
        public static Information? Tebibytes<T>(this T? value) where T : struct => Information.FromTebibytes(value == null ? (double?)null : Convert.ToDouble(value.Value));

        #endregion

        #region Terabit

        /// <inheritdoc cref="Information.FromTerabits(UnitsNet.QuantityValue)" />
        public static Information Terabits<T>(this T value) => Information.FromTerabits(Convert.ToDouble(value));

        /// <inheritdoc cref="Information.FromTerabits(UnitsNet.QuantityValue)" />
        public static Information? Terabits<T>(this T? value) where T : struct => Information.FromTerabits(value == null ? (double?)null : Convert.ToDouble(value.Value));

        #endregion

        #region Terabyte

        /// <inheritdoc cref="Information.FromTerabytes(UnitsNet.QuantityValue)" />
        public static Information Terabytes<T>(this T value) => Information.FromTerabytes(Convert.ToDouble(value));

        /// <inheritdoc cref="Information.FromTerabytes(UnitsNet.QuantityValue)" />
        public static Information? Terabytes<T>(this T? value) where T : struct => Information.FromTerabytes(value == null ? (double?)null : Convert.ToDouble(value.Value));

        #endregion

    }
}
#endif
