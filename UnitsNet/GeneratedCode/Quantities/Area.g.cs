//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by \generate-code.bat.
//
//     Changes to this file will be lost when the code is regenerated.
//     The build server regenerates the code before each build and a pre-build
//     step will regenerate the code on each local build.
//
//     See https://github.com/angularsen/UnitsNet/wiki/Adding-a-New-Unit for how to add or edit units.
//
//     Add CustomCode\Quantities\MyQuantity.extra.cs files to add code to generated quantities.
//     Add UnitDefinitions\MyQuantity.json and run generate-code.bat to generate new units or quantities.
//
// </auto-generated>
//------------------------------------------------------------------------------

// Licensed under MIT No Attribution, see LICENSE file at the root.
// Copyright 2013 Andreas Gullberg Larsen (andreas.larsen84@gmail.com). Maintained at https://github.com/angularsen/UnitsNet.

using System.Globalization;
using System.Resources;
using System.Runtime.Serialization;
using UnitsNet.Debug;

#nullable enable

// ReSharper disable once CheckNamespace

namespace UnitsNet
{
    /// <inheritdoc />
    /// <summary>
    ///     Area is a quantity that expresses the extent of a two-dimensional surface or shape, or planar lamina, in the plane. Area can be understood as the amount of material with a given thickness that would be necessary to fashion a model of the shape, or the amount of paint necessary to cover the surface with a single coat.[1] It is the two-dimensional analog of the length of a curve (a one-dimensional concept) or the volume of a solid (a three-dimensional concept).
    /// </summary>
    [DataContract]
    [DebuggerDisplay(QuantityDebugProxy.DisplayFormat)]
    [DebuggerTypeProxy(typeof(QuantityDebugProxy))]
    public readonly partial struct Area :
        IArithmeticQuantity<Area, AreaUnit>,
#if NET7_0_OR_GREATER
        IDivisionOperators<Area, Area, QuantityValue>,
        IMultiplyOperators<Area, Pressure, Force>,
        IMultiplyOperators<Area, SpecificWeight, ForcePerLength>,
        IMultiplyOperators<Area, ReciprocalLength, Length>,
        IDivisionOperators<Area, Length, Length>,
        IMultiplyOperators<Area, Density, LinearDensity>,
        IMultiplyOperators<Area, Illuminance, LuminousFlux>,
        IMultiplyOperators<Area, Luminance, LuminousIntensity>,
        IMultiplyOperators<Area, AreaDensity, Mass>,
        IMultiplyOperators<Area, MassFlux, MassFlow>,
        IMultiplyOperators<Area, HeatFlux, Power>,
        IMultiplyOperators<Area, ReciprocalArea, Ratio>,
        IDivisionOperators<Area, Volume, ReciprocalLength>,
        IMultiplyOperators<Area, ForcePerLength, Torque>,
        IMultiplyOperators<Area, Length, Volume>,
        IDivisionOperators<Area, ReciprocalLength, Volume>,
        IMultiplyOperators<Area, Speed, VolumeFlow>,
        IComparisonOperators<Area, Area, bool>,
        IParsable<Area>,
#endif
        IComparable,
        IComparable<Area>,
        IEquatable<Area>,
        IFormattable
    {
        /// <summary>
        ///     The numeric value this quantity was constructed with.
        /// </summary>
        [DataMember(Name = "Value", Order = 1, EmitDefaultValue = false)]
        private readonly QuantityValue _value;

        /// <summary>
        ///     The unit this quantity was constructed with.
        /// </summary>
        [DataMember(Name = "Unit", Order = 2, EmitDefaultValue = false)]
        private readonly AreaUnit? _unit;

        /// <summary>
        ///     Provides detailed information about the <see cref="Area"/> quantity, including its name, base unit, unit mappings, base dimensions, and conversion functions.
        /// </summary>
        public sealed class AreaInfo: QuantityInfo<Area, AreaUnit>
        {
            /// <inheritdoc />
            public AreaInfo(string name, AreaUnit baseUnit, IEnumerable<IUnitDefinition<AreaUnit>> unitMappings, Area zero, BaseDimensions baseDimensions,
                QuantityFromDelegate<Area, AreaUnit> fromDelegate, ResourceManager? unitAbbreviations)
                : base(name, baseUnit, unitMappings, zero, baseDimensions, fromDelegate, unitAbbreviations)
            {
            }

            /// <inheritdoc />
            public AreaInfo(string name, AreaUnit baseUnit, IEnumerable<IUnitDefinition<AreaUnit>> unitMappings, Area zero, BaseDimensions baseDimensions)
                : this(name, baseUnit, unitMappings, zero, baseDimensions, Area.From, new ResourceManager("UnitsNet.GeneratedCode.Resources.Area", typeof(Area).Assembly))
            {
            }

            /// <summary>
            ///     Creates a new instance of the <see cref="AreaInfo"/> class with the default settings for the Area quantity.
            /// </summary>
            /// <returns>A new instance of the <see cref="AreaInfo"/> class with the default settings.</returns>
            public static AreaInfo CreateDefault()
            {
                return new AreaInfo(nameof(Area), DefaultBaseUnit, GetDefaultMappings(), new Area(0, DefaultBaseUnit), DefaultBaseDimensions);
            }

            /// <summary>
            ///     Creates a new instance of the <see cref="AreaInfo"/> class with the default settings for the Area quantity and a callback for customizing the default unit mappings.
            /// </summary>
            /// <param name="customizeUnits">
            ///     A callback function for customizing the default unit mappings.
            /// </param>
            /// <returns>
            ///     A new instance of the <see cref="AreaInfo"/> class with the default settings.
            /// </returns>
            public static AreaInfo CreateDefault(Func<IEnumerable<UnitDefinition<AreaUnit>>, IEnumerable<IUnitDefinition<AreaUnit>>> customizeUnits)
            {
                return new AreaInfo(nameof(Area), DefaultBaseUnit, customizeUnits(GetDefaultMappings()), new Area(0, DefaultBaseUnit), DefaultBaseDimensions);
            }

            /// <summary>
            ///     The <see cref="BaseDimensions" /> for <see cref="Area"/> is L^2.
            /// </summary>
            public static BaseDimensions DefaultBaseDimensions { get; } = new BaseDimensions(2, 0, 0, 0, 0, 0, 0);

            /// <summary>
            ///     The default base unit of Area is SquareMeter. All conversions, as defined in the <see cref="GetDefaultMappings"/>, go via this value.
            /// </summary>
            public static AreaUnit DefaultBaseUnit { get; } = AreaUnit.SquareMeter;

            /// <summary>
            ///     Retrieves the default mappings for <see cref="AreaUnit"/>.
            /// </summary>
            /// <returns>An <see cref="IEnumerable{T}"/> of <see cref="UnitDefinition{AreaUnit}"/> representing the default unit mappings for Area.</returns>
            public static IEnumerable<UnitDefinition<AreaUnit>> GetDefaultMappings()
            {
                yield return new (AreaUnit.Acre, "Acre", "Acres", BaseUnits.Undefined,
                     new QuantityValue(78125, 316160658)             
                );
                yield return new (AreaUnit.Hectare, "Hectare", "Hectares", BaseUnits.Undefined,
                     new QuantityValue(1, 10000)             
                );
                yield return new (AreaUnit.SquareCentimeter, "SquareCentimeter", "SquareCentimeters", new BaseUnits(length: LengthUnit.Centimeter),
                     10000             
                );
                yield return new (AreaUnit.SquareDecimeter, "SquareDecimeter", "SquareDecimeters", new BaseUnits(length: LengthUnit.Decimeter),
                     100             
                );
                yield return new (AreaUnit.SquareFoot, "SquareFoot", "SquareFeet", new BaseUnits(length: LengthUnit.Foot),
                     new QuantityValue(1562500, 145161)             
                );
                yield return new (AreaUnit.SquareInch, "SquareInch", "SquareInches", new BaseUnits(length: LengthUnit.Inch),
                     new QuantityValue(25000000, 16129)             
                );
                yield return new (AreaUnit.SquareKilometer, "SquareKilometer", "SquareKilometers", new BaseUnits(length: LengthUnit.Kilometer),
                     new QuantityValue(1, 1000000)             
                );
                yield return new (AreaUnit.SquareMeter, "SquareMeter", "SquareMeters", new BaseUnits(length: LengthUnit.Meter));
                yield return new (AreaUnit.SquareMicrometer, "SquareMicrometer", "SquareMicrometers", new BaseUnits(length: LengthUnit.Micrometer),
                     1000000000000             
                );
                yield return new (AreaUnit.SquareMile, "SquareMile", "SquareMiles", new BaseUnits(length: LengthUnit.Mile),
                     new QuantityValue(15625, 40468564224)             
                );
                yield return new (AreaUnit.SquareMillimeter, "SquareMillimeter", "SquareMillimeters", new BaseUnits(length: LengthUnit.Millimeter),
                     1000000             
                );
                yield return new (AreaUnit.SquareNauticalMile, "SquareNauticalMile", "SquareNauticalMiles", BaseUnits.Undefined,
                     new QuantityValue(1, 3429904)             
                );
                yield return new (AreaUnit.SquareYard, "SquareYard", "SquareYards", new BaseUnits(length: LengthUnit.Yard),
                     new QuantityValue(1562500, 1306449)             
                );
                yield return new (AreaUnit.UsSurveySquareFoot, "UsSurveySquareFoot", "UsSurveySquareFeet", new BaseUnits(length: LengthUnit.UsSurveyFoot),
                     new QuantityValue(15499969, 1440000)             
                );
            }
        }

        static Area()
        {
            Info = UnitsNetSetup.CreateQuantityInfo(AreaInfo.CreateDefault);
        }

        /// <summary>
        ///     Creates the quantity with the given numeric value and unit.
        /// </summary>
        /// <param name="value">The numeric value to construct this quantity with.</param>
        /// <param name="unit">The unit representation to construct this quantity with.</param>
        public Area(QuantityValue value, AreaUnit unit)
        {
            _value = value;
            _unit = unit;
        }

        /// <summary>
        /// Creates an instance of the quantity with the given numeric value in units compatible with the given <see cref="UnitSystem"/>.
        /// If multiple compatible units were found, the first match is used.
        /// </summary>
        /// <param name="value">The numeric value to construct this quantity with.</param>
        /// <param name="unitSystem">The unit system to create the quantity with.</param>
        /// <exception cref="ArgumentNullException">The given <see cref="UnitSystem"/> is null.</exception>
        /// <exception cref="ArgumentException">No unit was found for the given <see cref="UnitSystem"/>.</exception>
        public Area(QuantityValue value, UnitSystem unitSystem)
        {
            _value = value;
            _unit = Info.GetDefaultUnit(unitSystem);
        }

        #region Static Properties

        /// <summary>
        ///     The <see cref="UnitConverter" /> containing the default generated conversion functions for <see cref="Area" /> instances.
        /// </summary>
        [Obsolete("Replaced by UnitConverter.Default")]
        public static UnitConverter DefaultConversionFunctions => UnitConverter.Default;

        /// <inheritdoc cref="IQuantity.QuantityInfo"/>
        public static QuantityInfo<Area, AreaUnit> Info { get; }

        /// <summary>
        ///     The <see cref="BaseDimensions" /> of this quantity.
        /// </summary>
        public static BaseDimensions BaseDimensions => Info.BaseDimensions;

        /// <summary>
        ///     The base unit of Area, which is SquareMeter. All conversions go via this value.
        /// </summary>
        public static AreaUnit BaseUnit => Info.BaseUnitInfo.Value;

        /// <summary>
        ///     All units of measurement for the Area quantity.
        /// </summary>
        public static IReadOnlyCollection<AreaUnit> Units => Info.Units;

        /// <summary>
        ///     Gets an instance of this quantity with a value of 0 in the base unit SquareMeter.
        /// </summary>
        public static Area Zero => Info.Zero;

        #endregion

        #region Properties

        /// <inheritdoc />
        public QuantityValue Value => _value;

        /// <inheritdoc />
        public AreaUnit Unit => _unit.GetValueOrDefault(BaseUnit);

        /// <inheritdoc />
        public QuantityInfo<Area, AreaUnit> QuantityInfo => Info;

        /// <summary>
        ///     The <see cref="BaseDimensions" /> of this quantity.
        /// </summary>
        public BaseDimensions Dimensions => Area.BaseDimensions;

        #region Explicit implementations

        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        UnitKey IQuantity.UnitKey => UnitKey.ForUnit(Unit);

#if NETSTANDARD2_0
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        IQuantityInstanceInfo<Area> IQuantityOfType<Area>.QuantityInfo => Info;

        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        QuantityInfo<AreaUnit> IQuantity<AreaUnit>.QuantityInfo => Info;

        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        QuantityInfo IQuantity.QuantityInfo => Info;

        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Enum IQuantity.Unit => Unit;
#endif

        #endregion

        #endregion

        #region Conversion Properties

        /// <summary>
        ///     Gets a <see cref="QuantityValue"/> value of this quantity converted into <see cref="AreaUnit.Acre"/>
        /// </summary>
        public QuantityValue Acres => this.As(AreaUnit.Acre);

        /// <summary>
        ///     Gets a <see cref="QuantityValue"/> value of this quantity converted into <see cref="AreaUnit.Hectare"/>
        /// </summary>
        public QuantityValue Hectares => this.As(AreaUnit.Hectare);

        /// <summary>
        ///     Gets a <see cref="QuantityValue"/> value of this quantity converted into <see cref="AreaUnit.SquareCentimeter"/>
        /// </summary>
        public QuantityValue SquareCentimeters => this.As(AreaUnit.SquareCentimeter);

        /// <summary>
        ///     Gets a <see cref="QuantityValue"/> value of this quantity converted into <see cref="AreaUnit.SquareDecimeter"/>
        /// </summary>
        public QuantityValue SquareDecimeters => this.As(AreaUnit.SquareDecimeter);

        /// <summary>
        ///     Gets a <see cref="QuantityValue"/> value of this quantity converted into <see cref="AreaUnit.SquareFoot"/>
        /// </summary>
        public QuantityValue SquareFeet => this.As(AreaUnit.SquareFoot);

        /// <summary>
        ///     Gets a <see cref="QuantityValue"/> value of this quantity converted into <see cref="AreaUnit.SquareInch"/>
        /// </summary>
        public QuantityValue SquareInches => this.As(AreaUnit.SquareInch);

        /// <summary>
        ///     Gets a <see cref="QuantityValue"/> value of this quantity converted into <see cref="AreaUnit.SquareKilometer"/>
        /// </summary>
        public QuantityValue SquareKilometers => this.As(AreaUnit.SquareKilometer);

        /// <summary>
        ///     Gets a <see cref="QuantityValue"/> value of this quantity converted into <see cref="AreaUnit.SquareMeter"/>
        /// </summary>
        public QuantityValue SquareMeters => this.As(AreaUnit.SquareMeter);

        /// <summary>
        ///     Gets a <see cref="QuantityValue"/> value of this quantity converted into <see cref="AreaUnit.SquareMicrometer"/>
        /// </summary>
        public QuantityValue SquareMicrometers => this.As(AreaUnit.SquareMicrometer);

        /// <summary>
        ///     Gets a <see cref="QuantityValue"/> value of this quantity converted into <see cref="AreaUnit.SquareMile"/>
        /// </summary>
        public QuantityValue SquareMiles => this.As(AreaUnit.SquareMile);

        /// <summary>
        ///     Gets a <see cref="QuantityValue"/> value of this quantity converted into <see cref="AreaUnit.SquareMillimeter"/>
        /// </summary>
        public QuantityValue SquareMillimeters => this.As(AreaUnit.SquareMillimeter);

        /// <summary>
        ///     Gets a <see cref="QuantityValue"/> value of this quantity converted into <see cref="AreaUnit.SquareNauticalMile"/>
        /// </summary>
        public QuantityValue SquareNauticalMiles => this.As(AreaUnit.SquareNauticalMile);

        /// <summary>
        ///     Gets a <see cref="QuantityValue"/> value of this quantity converted into <see cref="AreaUnit.SquareYard"/>
        /// </summary>
        public QuantityValue SquareYards => this.As(AreaUnit.SquareYard);

        /// <summary>
        ///     Gets a <see cref="QuantityValue"/> value of this quantity converted into <see cref="AreaUnit.UsSurveySquareFoot"/>
        /// </summary>
        public QuantityValue UsSurveySquareFeet => this.As(AreaUnit.UsSurveySquareFoot);

        #endregion

        #region Static Methods

        /// <summary>
        ///     Get unit abbreviation string.
        /// </summary>
        /// <param name="unit">Unit to get abbreviation for.</param>
        /// <returns>Unit abbreviation string.</returns>
        public static string GetAbbreviation(AreaUnit unit)
        {
            return GetAbbreviation(unit, null);
        }

        /// <summary>
        ///     Get unit abbreviation string.
        /// </summary>
        /// <param name="unit">Unit to get abbreviation for.</param>
        /// <returns>Unit abbreviation string.</returns>
        /// <param name="provider">Format to use for localization. Defaults to <see cref="CultureInfo.CurrentCulture" /> if null.</param>
        public static string GetAbbreviation(AreaUnit unit, IFormatProvider? provider)
        {
            return UnitsNetSetup.Default.UnitAbbreviations.GetDefaultAbbreviation(unit, provider);
        }

        #endregion

        #region Static Factory Methods

        /// <summary>
        ///     Creates a <see cref="Area"/> from <see cref="AreaUnit.Acre"/>.
        /// </summary>
        public static Area FromAcres(QuantityValue value)
        {
            return new Area(value, AreaUnit.Acre);
        }

        /// <summary>
        ///     Creates a <see cref="Area"/> from <see cref="AreaUnit.Hectare"/>.
        /// </summary>
        public static Area FromHectares(QuantityValue value)
        {
            return new Area(value, AreaUnit.Hectare);
        }

        /// <summary>
        ///     Creates a <see cref="Area"/> from <see cref="AreaUnit.SquareCentimeter"/>.
        /// </summary>
        public static Area FromSquareCentimeters(QuantityValue value)
        {
            return new Area(value, AreaUnit.SquareCentimeter);
        }

        /// <summary>
        ///     Creates a <see cref="Area"/> from <see cref="AreaUnit.SquareDecimeter"/>.
        /// </summary>
        public static Area FromSquareDecimeters(QuantityValue value)
        {
            return new Area(value, AreaUnit.SquareDecimeter);
        }

        /// <summary>
        ///     Creates a <see cref="Area"/> from <see cref="AreaUnit.SquareFoot"/>.
        /// </summary>
        public static Area FromSquareFeet(QuantityValue value)
        {
            return new Area(value, AreaUnit.SquareFoot);
        }

        /// <summary>
        ///     Creates a <see cref="Area"/> from <see cref="AreaUnit.SquareInch"/>.
        /// </summary>
        public static Area FromSquareInches(QuantityValue value)
        {
            return new Area(value, AreaUnit.SquareInch);
        }

        /// <summary>
        ///     Creates a <see cref="Area"/> from <see cref="AreaUnit.SquareKilometer"/>.
        /// </summary>
        public static Area FromSquareKilometers(QuantityValue value)
        {
            return new Area(value, AreaUnit.SquareKilometer);
        }

        /// <summary>
        ///     Creates a <see cref="Area"/> from <see cref="AreaUnit.SquareMeter"/>.
        /// </summary>
        public static Area FromSquareMeters(QuantityValue value)
        {
            return new Area(value, AreaUnit.SquareMeter);
        }

        /// <summary>
        ///     Creates a <see cref="Area"/> from <see cref="AreaUnit.SquareMicrometer"/>.
        /// </summary>
        public static Area FromSquareMicrometers(QuantityValue value)
        {
            return new Area(value, AreaUnit.SquareMicrometer);
        }

        /// <summary>
        ///     Creates a <see cref="Area"/> from <see cref="AreaUnit.SquareMile"/>.
        /// </summary>
        public static Area FromSquareMiles(QuantityValue value)
        {
            return new Area(value, AreaUnit.SquareMile);
        }

        /// <summary>
        ///     Creates a <see cref="Area"/> from <see cref="AreaUnit.SquareMillimeter"/>.
        /// </summary>
        public static Area FromSquareMillimeters(QuantityValue value)
        {
            return new Area(value, AreaUnit.SquareMillimeter);
        }

        /// <summary>
        ///     Creates a <see cref="Area"/> from <see cref="AreaUnit.SquareNauticalMile"/>.
        /// </summary>
        public static Area FromSquareNauticalMiles(QuantityValue value)
        {
            return new Area(value, AreaUnit.SquareNauticalMile);
        }

        /// <summary>
        ///     Creates a <see cref="Area"/> from <see cref="AreaUnit.SquareYard"/>.
        /// </summary>
        public static Area FromSquareYards(QuantityValue value)
        {
            return new Area(value, AreaUnit.SquareYard);
        }

        /// <summary>
        ///     Creates a <see cref="Area"/> from <see cref="AreaUnit.UsSurveySquareFoot"/>.
        /// </summary>
        public static Area FromUsSurveySquareFeet(QuantityValue value)
        {
            return new Area(value, AreaUnit.UsSurveySquareFoot);
        }

        /// <summary>
        ///     Dynamically convert from value and unit enum <see cref="AreaUnit" /> to <see cref="Area" />.
        /// </summary>
        /// <param name="value">Value to convert from.</param>
        /// <param name="fromUnit">Unit to convert from.</param>
        /// <returns>Area unit value.</returns>
        public static Area From(QuantityValue value, AreaUnit fromUnit)
        {
            return new Area(value, fromUnit);
        }

        #endregion

        #region Static Parse Methods

        /// <summary>
        ///     Parse a string with one or two quantities of the format "&lt;quantity&gt; &lt;unit&gt;".
        /// </summary>
        /// <param name="str">String to parse. Typically in the form: {number} {unit}</param>
        /// <example>
        ///     Length.Parse("5.5 m", CultureInfo.GetCultureInfo("en-US"));
        /// </example>
        /// <exception cref="ArgumentNullException">The value of 'str' cannot be null. </exception>
        /// <exception cref="ArgumentException">
        ///     Expected string to have one or two pairs of quantity and unit in the format
        ///     "&lt;quantity&gt; &lt;unit&gt;". Eg. "5.5 m" or "1ft 2in"
        /// </exception>
        /// <exception cref="AmbiguousUnitParseException">
        ///     More than one unit is represented by the specified unit abbreviation.
        ///     Example: Volume.Parse("1 cup") will throw, because it can refer to any of
        ///     <see cref="VolumeUnit.MetricCup" />, <see cref="VolumeUnit.UsLegalCup" /> and <see cref="VolumeUnit.UsCustomaryCup" />.
        /// </exception>
        /// <exception cref="UnitsNetException">
        ///     If anything else goes wrong, typically due to a bug or unhandled case.
        ///     We wrap exceptions in <see cref="UnitsNetException" /> to allow you to distinguish
        ///     Units.NET exceptions from other exceptions.
        /// </exception>
        public static Area Parse(string str)
        {
            return Parse(str, null);
        }

        /// <summary>
        ///     Parse a string with one or two quantities of the format "&lt;quantity&gt; &lt;unit&gt;".
        /// </summary>
        /// <param name="str">String to parse. Typically in the form: {number} {unit}</param>
        /// <example>
        ///     Length.Parse("5.5 m", CultureInfo.GetCultureInfo("en-US"));
        /// </example>
        /// <exception cref="ArgumentNullException">The value of 'str' cannot be null. </exception>
        /// <exception cref="ArgumentException">
        ///     Expected string to have one or two pairs of quantity and unit in the format
        ///     "&lt;quantity&gt; &lt;unit&gt;". Eg. "5.5 m" or "1ft 2in"
        /// </exception>
        /// <exception cref="AmbiguousUnitParseException">
        ///     More than one unit is represented by the specified unit abbreviation.
        ///     Example: Volume.Parse("1 cup") will throw, because it can refer to any of
        ///     <see cref="VolumeUnit.MetricCup" />, <see cref="VolumeUnit.UsLegalCup" /> and <see cref="VolumeUnit.UsCustomaryCup" />.
        /// </exception>
        /// <exception cref="UnitsNetException">
        ///     If anything else goes wrong, typically due to a bug or unhandled case.
        ///     We wrap exceptions in <see cref="UnitsNetException" /> to allow you to distinguish
        ///     Units.NET exceptions from other exceptions.
        /// </exception>
        /// <param name="provider">Format to use when parsing number and unit. Defaults to <see cref="CultureInfo.CurrentCulture" /> if null.</param>
        public static Area Parse(string str, IFormatProvider? provider)
        {
            return QuantityParser.Default.Parse<Area, AreaUnit>(str, provider, From);
        }

        /// <summary>
        ///     Try to parse a string with one or two quantities of the format "&lt;quantity&gt; &lt;unit&gt;".
        /// </summary>
        /// <param name="str">String to parse. Typically in the form: {number} {unit}</param>
        /// <param name="result">Resulting unit quantity if successful.</param>
        /// <example>
        ///     Length.Parse("5.5 m", CultureInfo.GetCultureInfo("en-US"));
        /// </example>
        public static bool TryParse([NotNullWhen(true)]string? str, out Area result)
        {
            return TryParse(str, null, out result);
        }

        /// <summary>
        ///     Try to parse a string with one or two quantities of the format "&lt;quantity&gt; &lt;unit&gt;".
        /// </summary>
        /// <param name="str">String to parse. Typically in the form: {number} {unit}</param>
        /// <param name="result">Resulting unit quantity if successful.</param>
        /// <returns>True if successful, otherwise false.</returns>
        /// <example>
        ///     Length.Parse("5.5 m", CultureInfo.GetCultureInfo("en-US"));
        /// </example>
        /// <param name="provider">Format to use when parsing number and unit. Defaults to <see cref="CultureInfo.CurrentCulture" /> if null.</param>
        public static bool TryParse([NotNullWhen(true)]string? str, IFormatProvider? provider, out Area result)
        {
            return QuantityParser.Default.TryParse<Area, AreaUnit>(str, provider, From, out result);
        }

        /// <summary>
        ///     Parse a unit string.
        /// </summary>
        /// <param name="str">String to parse. Typically in the form: {number} {unit}</param>
        /// <example>
        ///     Length.ParseUnit("m", CultureInfo.GetCultureInfo("en-US"));
        /// </example>
        /// <exception cref="ArgumentNullException">The value of 'str' cannot be null. </exception>
        /// <exception cref="UnitsNetException">Error parsing string.</exception>
        public static AreaUnit ParseUnit(string str)
        {
            return ParseUnit(str, null);
        }

        /// <summary>
        ///     Parse a unit string.
        /// </summary>
        /// <param name="str">String to parse. Typically in the form: {number} {unit}</param>
        /// <param name="provider">Format to use when parsing the unit. Defaults to <see cref="CultureInfo.CurrentCulture" /> if null.</param>
        /// <example>
        ///     Length.ParseUnit("m", CultureInfo.GetCultureInfo("en-US"));
        /// </example>
        /// <exception cref="ArgumentNullException">The value of 'str' cannot be null. </exception>
        /// <exception cref="UnitsNetException">Error parsing string.</exception>
        public static AreaUnit ParseUnit(string str, IFormatProvider? provider)
        {
            return UnitParser.Default.Parse(str, Info.UnitInfos, provider).Value;
        }

        /// <inheritdoc cref="TryParseUnit(string,IFormatProvider?,out UnitsNet.Units.AreaUnit)"/>
        public static bool TryParseUnit([NotNullWhen(true)]string? str, out AreaUnit unit)
        {
            return TryParseUnit(str, null, out unit);
        }

        /// <summary>
        ///     Parse a unit string.
        /// </summary>
        /// <param name="str">String to parse. Typically in the form: {number} {unit}</param>
        /// <param name="unit">The parsed unit if successful.</param>
        /// <returns>True if successful, otherwise false.</returns>
        /// <example>
        ///     Length.TryParseUnit("m", CultureInfo.GetCultureInfo("en-US"));
        /// </example>
        /// <param name="provider">Format to use when parsing the unit. Defaults to <see cref="CultureInfo.CurrentCulture" /> if null.</param>
        public static bool TryParseUnit([NotNullWhen(true)]string? str, IFormatProvider? provider, out AreaUnit unit)
        {
            return UnitParser.Default.TryParse(str, Info, provider, out unit);
        }

        #endregion

        #region Arithmetic Operators

        /// <summary>Negate the value.</summary>
        public static Area operator -(Area right)
        {
            return new Area(-right.Value, right.Unit);
        }

        /// <summary>Get <see cref="Area"/> from adding two <see cref="Area"/>.</summary>
        public static Area operator +(Area left, Area right)
        {
            return new Area(left.Value + right.As(left.Unit), left.Unit);
        }

        /// <summary>Get <see cref="Area"/> from subtracting two <see cref="Area"/>.</summary>
        public static Area operator -(Area left, Area right)
        {
            return new Area(left.Value - right.As(left.Unit), left.Unit);
        }

        /// <summary>Get <see cref="Area"/> from multiplying value and <see cref="Area"/>.</summary>
        public static Area operator *(QuantityValue left, Area right)
        {
            return new Area(left * right.Value, right.Unit);
        }

        /// <summary>Get <see cref="Area"/> from multiplying value and <see cref="Area"/>.</summary>
        public static Area operator *(Area left, QuantityValue right)
        {
            return new Area(left.Value * right, left.Unit);
        }

        /// <summary>Get <see cref="Area"/> from dividing <see cref="Area"/> by value.</summary>
        public static Area operator /(Area left, QuantityValue right)
        {
            return new Area(left.Value / right, left.Unit);
        }

        /// <summary>Get ratio value from dividing <see cref="Area"/> by <see cref="Area"/>.</summary>
        public static QuantityValue operator /(Area left, Area right)
        {
            return left.SquareMeters / right.SquareMeters;
        }

        #endregion

        #region Relational Operators

        /// <summary>Calculates the inverse of this quantity.</summary>
        /// <returns>The corresponding inverse quantity, <see cref="ReciprocalArea"/>.</returns>
        public ReciprocalArea Inverse()
        {
            return UnitConverter.Default.ConvertTo(Value, Unit, ReciprocalArea.Info);
        }

        /// <summary>Get <see cref="Force"/> from <see cref="Area"/> * <see cref="Pressure"/>.</summary>
        public static Force operator *(Area area, Pressure pressure)
        {
            return Force.FromNewtons(area.SquareMeters * pressure.Pascals);
        }

        /// <summary>Get <see cref="ForcePerLength"/> from <see cref="Area"/> * <see cref="SpecificWeight"/>.</summary>
        public static ForcePerLength operator *(Area area, SpecificWeight specificWeight)
        {
            return ForcePerLength.FromNewtonsPerMeter(area.SquareMeters * specificWeight.NewtonsPerCubicMeter);
        }

        /// <summary>Get <see cref="Length"/> from <see cref="Area"/> * <see cref="ReciprocalLength"/>.</summary>
        public static Length operator *(Area area, ReciprocalLength reciprocalLength)
        {
            return Length.FromMeters(area.SquareMeters * reciprocalLength.InverseMeters);
        }

        /// <summary>Get <see cref="Length"/> from <see cref="Area"/> / <see cref="Length"/>.</summary>
        public static Length operator /(Area area, Length length)
        {
            return Length.FromMeters(area.SquareMeters / length.Meters);
        }

        /// <summary>Get <see cref="LinearDensity"/> from <see cref="Area"/> * <see cref="Density"/>.</summary>
        public static LinearDensity operator *(Area area, Density density)
        {
            return LinearDensity.FromKilogramsPerMeter(area.SquareMeters * density.KilogramsPerCubicMeter);
        }

        /// <summary>Get <see cref="LuminousFlux"/> from <see cref="Area"/> * <see cref="Illuminance"/>.</summary>
        public static LuminousFlux operator *(Area area, Illuminance illuminance)
        {
            return LuminousFlux.FromLumens(area.SquareMeters * illuminance.Lux);
        }

        /// <summary>Get <see cref="LuminousIntensity"/> from <see cref="Area"/> * <see cref="Luminance"/>.</summary>
        public static LuminousIntensity operator *(Area area, Luminance luminance)
        {
            return LuminousIntensity.FromCandela(area.SquareMeters * luminance.CandelasPerSquareMeter);
        }

        /// <summary>Get <see cref="Mass"/> from <see cref="Area"/> * <see cref="AreaDensity"/>.</summary>
        public static Mass operator *(Area area, AreaDensity areaDensity)
        {
            return Mass.FromKilograms(area.SquareMeters * areaDensity.KilogramsPerSquareMeter);
        }

        /// <summary>Get <see cref="MassFlow"/> from <see cref="Area"/> * <see cref="MassFlux"/>.</summary>
        public static MassFlow operator *(Area area, MassFlux massFlux)
        {
            return MassFlow.FromKilogramsPerSecond(area.SquareMeters * massFlux.KilogramsPerSecondPerSquareMeter);
        }

        /// <summary>Get <see cref="Power"/> from <see cref="Area"/> * <see cref="HeatFlux"/>.</summary>
        public static Power operator *(Area area, HeatFlux heatFlux)
        {
            return Power.FromWatts(area.SquareMeters * heatFlux.WattsPerSquareMeter);
        }

        /// <summary>Get <see cref="Ratio"/> from <see cref="Area"/> * <see cref="ReciprocalArea"/>.</summary>
        public static Ratio operator *(Area area, ReciprocalArea reciprocalArea)
        {
            return Ratio.FromDecimalFractions(area.SquareMeters * reciprocalArea.InverseSquareMeters);
        }

        /// <summary>Get <see cref="ReciprocalLength"/> from <see cref="Area"/> / <see cref="Volume"/>.</summary>
        public static ReciprocalLength operator /(Area area, Volume volume)
        {
            return ReciprocalLength.FromInverseMeters(area.SquareMeters / volume.CubicMeters);
        }

        /// <summary>Get <see cref="Torque"/> from <see cref="Area"/> * <see cref="ForcePerLength"/>.</summary>
        public static Torque operator *(Area area, ForcePerLength forcePerLength)
        {
            return Torque.FromNewtonMeters(area.SquareMeters * forcePerLength.NewtonsPerMeter);
        }

        /// <summary>Get <see cref="Volume"/> from <see cref="Area"/> * <see cref="Length"/>.</summary>
        public static Volume operator *(Area area, Length length)
        {
            return Volume.FromCubicMeters(area.SquareMeters * length.Meters);
        }

        /// <summary>Get <see cref="Volume"/> from <see cref="Area"/> / <see cref="ReciprocalLength"/>.</summary>
        public static Volume operator /(Area area, ReciprocalLength reciprocalLength)
        {
            return Volume.FromCubicMeters(area.SquareMeters / reciprocalLength.InverseMeters);
        }

        /// <summary>Get <see cref="VolumeFlow"/> from <see cref="Area"/> * <see cref="Speed"/>.</summary>
        public static VolumeFlow operator *(Area area, Speed speed)
        {
            return VolumeFlow.FromCubicMetersPerSecond(area.SquareMeters * speed.MetersPerSecond);
        }

        #endregion

        #region Equality / IComparable

        /// <summary>Returns true if less or equal to.</summary>
        public static bool operator <=(Area left, Area right)
        {
            return left.Value <= right.As(left.Unit);
        }

        /// <summary>Returns true if greater than or equal to.</summary>
        public static bool operator >=(Area left, Area right)
        {
            return left.Value >= right.As(left.Unit);
        }

        /// <summary>Returns true if less than.</summary>
        public static bool operator <(Area left, Area right)
        {
            return left.Value < right.As(left.Unit);
        }

        /// <summary>Returns true if greater than.</summary>
        public static bool operator >(Area left, Area right)
        {
            return left.Value > right.As(left.Unit);
        }

        /// <summary>Indicates strict equality of two <see cref="Area"/> quantities.</summary>
        public static bool operator ==(Area left, Area right)
        {
            return left.Equals(right);
        }

        /// <summary>Indicates strict inequality of two <see cref="Area"/> quantities.</summary>
        public static bool operator !=(Area left, Area right)
        {
            return !(left == right);
        }

        /// <inheritdoc />
        /// <summary>Indicates strict equality of two <see cref="Area"/> quantities.</summary>
        public override bool Equals(object? obj)
        {
            if (obj is not Area otherQuantity)
                return false;

            return Equals(otherQuantity);
        }

        /// <inheritdoc />
        /// <summary>Indicates strict equality of two <see cref="Area"/> quantities.</summary>
        public bool Equals(Area other)
        {
            return _value.Equals(other.As(this.Unit));
        }

        /// <summary>
        ///     Returns the hash code for this instance.
        /// </summary>
        /// <returns>A hash code for the current Area.</returns>
        public override int GetHashCode()
        {
            return Comparison.GetHashCode(typeof(Area), this.As(BaseUnit));
        }
        
        /// <inheritdoc  cref="CompareTo(Area)" />
        /// <param name="obj">An object to compare with this instance.</param>
        /// <exception cref="T:System.ArgumentException">
        ///    <paramref name="obj" /> is not the same type as this instance.
        /// </exception>
        public int CompareTo(object? obj)
        {
            if (obj is not Area otherQuantity)
                throw obj is null ? new ArgumentNullException(nameof(obj)) : ExceptionHelper.CreateArgumentException<Area>(obj, nameof(obj));

            return CompareTo(otherQuantity);
        }

        /// <summary>
        ///     Compares the current <see cref="Area"/> with another <see cref="Area"/> and returns an integer that indicates
        ///     whether the current instance precedes, follows, or occurs in the same position in the sort order as the other quantity, when converted to the same unit.
        /// </summary>
        /// <param name="other">A quantity to compare with this instance.</param>
        /// <returns>A value that indicates the relative order of the quantities being compared. The return value has these meanings:
        ///     <list type="table">
        ///         <listheader><term> Value</term><description> Meaning</description></listheader>
        ///         <item><term> Less than zero</term><description> This instance precedes <paramref name="other" /> in the sort order.</description></item>
        ///         <item><term> Zero</term><description> This instance occurs in the same position in the sort order as <paramref name="other" />.</description></item>
        ///         <item><term> Greater than zero</term><description> This instance follows <paramref name="other" /> in the sort order.</description></item>
        ///     </list>
        /// </returns>
        public int CompareTo(Area other)
        {
            return _value.CompareTo(other.As(this.Unit));
        }

        #endregion

        #region ToString Methods

        /// <summary>
        ///     Gets the default string representation of value and unit.
        /// </summary>
        /// <returns>String representation.</returns>
        public override string ToString()
        {
            return ToString(null, null);
        }

        /// <inheritdoc cref="QuantityFormatter.Format{TQuantity}(TQuantity, string, IFormatProvider)"/>
        /// <summary>
        /// Gets the string representation of this instance in the specified format string using the specified format provider, or <see cref="CultureInfo.CurrentCulture" /> if null.
        /// </summary>
        public string ToString(string? format, IFormatProvider? provider)
        {
            return QuantityFormatter.Default.Format(this, format, provider);
        }

        #endregion

    }
}
